'use strict';

exports.__esModule = true;
exports.default = undefined;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _class, _temp;

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _nextUtil = require('../../../next-util/lib/index.js');

var _nextBalloon = require('../../../next-balloon/lib/index.js');

var _nextBalloon2 = _interopRequireDefault(_nextBalloon);

var _utils = require('../utils.js');

var _scale = require('./scale.js');

var _scale2 = _interopRequireDefault(_scale);

var _track = require('./track.js');

var _track2 = _interopRequireDefault(_track);

var _selected = require('./selected.js');

var _selected2 = _interopRequireDefault(_selected);

var _mark = require('./mark.js');

var _mark2 = _interopRequireDefault(_mark);

var _slider = require('./slider.js');

var _slider2 = _interopRequireDefault(_slider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Tooltip = _nextBalloon2.default.Tooltip;
var noop = _nextUtil.func.noop,
    bindCtx = _nextUtil.func.bindCtx;


function _isMultiple(slider) {
    return slider === 'double';
}

function LowerSlider(props) {
    var hasTip = props.hasTip,
        value = props.value,
        tipRender = props.tipRender,
        slider = props.slider,
        tooltipVisible = props.tooltipVisible,
        onTooltipVisibleChange = props.onTooltipVisibleChange,
        tooltipAnimation = props.tooltipAnimation,
        disabled = props.disabled;


    if (_isMultiple(slider)) {
        return hasTip && !disabled ? _react2.default.createElement(
            Tooltip,
            {
                popupProps: {
                    visible: tooltipVisible,
                    onVisibleChange: onTooltipVisibleChange,
                    animation: tooltipAnimation
                },
                trigger: (0, _slider2.default)((0, _extends3.default)({}, props, { value: value[0] })),
                align: 't'
            },
            tipRender('' + value[0])
        ) : (0, _slider2.default)((0, _extends3.default)({}, props, { value: value[0] }));
    }
    return null;
}

LowerSlider.propTypes = {
    hasTip: _propTypes2.default.bool,
    tooltipVisible: _propTypes2.default.bool,
    onTooltipVisibleChange: _propTypes2.default.func,
    tooltipAnimation: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.object]),
    value: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
    tipRender: _propTypes2.default.func,
    slider: _propTypes2.default.oneOf(['single', 'double']),
    disabled: _propTypes2.default.bool
};

function UpperSlider(props) {
    var hasTip = props.hasTip,
        value = props.value,
        tipRender = props.tipRender,
        slider = props.slider,
        tooltipVisible = props.tooltipVisible,
        onTooltipVisibleChange = props.onTooltipVisibleChange,
        tooltipAnimation = props.tooltipAnimation,
        disabled = props.disabled;

    if (_isMultiple(slider)) {
        return hasTip && !disabled ? _react2.default.createElement(
            Tooltip,
            {
                popupProps: {
                    visible: tooltipVisible,
                    onVisibleChange: onTooltipVisibleChange,
                    animation: tooltipAnimation
                },
                trigger: (0, _slider2.default)((0, _extends3.default)({}, props, { value: value[1] })),
                align: 't'
            },
            tipRender(value[1])
        ) : (0, _slider2.default)((0, _extends3.default)({}, props, { value: value[1] }));
    }
    return hasTip && !disabled ? _react2.default.createElement(
        Tooltip,
        {
            popupProps: {
                visible: tooltipVisible,
                onVisibleChange: onTooltipVisibleChange,
                animation: tooltipAnimation
            },
            animation: {
                in: 'fadeInUp',
                out: 'fadeOutDown'
            },
            shouldUpdatePosition: true, trigger: (0, _slider2.default)(props),
            align: 't'
        },
        tipRender(value)
    ) : (0, _slider2.default)(props);
}

UpperSlider.propTypes = {
    hasTip: _propTypes2.default.bool,
    tooltipVisible: _propTypes2.default.bool,
    onTooltipVisibleChange: _propTypes2.default.func,
    tooltipAnimation: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.object]),
    value: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
    tipRender: _propTypes2.default.func,
    slider: _propTypes2.default.oneOf(['single', 'double']),
    disabled: _propTypes2.default.bool
};

function pauseEvent(e) {
    e.stopPropagation();
    e.preventDefault();
}

/** Range */
var Range = (_temp = _class = function (_React$Component) {
    (0, _inherits3.default)(Range, _React$Component);

    function Range(props) {
        (0, _classCallCheck3.default)(this, Range);

        var _this = (0, _possibleConstructorReturn3.default)(this, _React$Component.call(this, props));

        var min = props.min;

        var initialValue = _isMultiple(props.slider) ? [min, min] : min;
        var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
        var value = props.value !== undefined ? props.value : defaultValue;

        _this.state = {
            value: value,
            tempValue: value,
            hasMovingClass: false,
            lowerTooltipVisible: false,
            upperTooltipVisible: false,
            tooltipAnimation: true
        };

        bindCtx(_this, ['handleLowerTooltipVisibleChange', 'handleUpperTooltipVisibleChange']);
        return _this;
    }

    Range.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var min = this.props.min;

        var initialValue = _isMultiple(nextProps.slider) ? [min, min] : min;
        if ('value' in nextProps) {
            var value = nextProps.value;

            if (value === undefined) {
                // value设置undefined,reset为初始值
                value = initialValue;
            }
            this.setState({
                value: value,
                tempValue: value
            });
        }
    };

    Range.prototype._marksToScales = function _marksToScales(marks) {
        var result = [];
        if (Object.prototype.toString.call(marks) === '[object Object]') {
            for (var key in marks) {
                if (Object.hasOwnProperty.call(marks, key)) {
                    result.push(parseInt(key));
                }
            }
        } else {
            result = marks;
        }
        return result;
    };

    Range.prototype._calcScales = function _calcScales() {
        var _props = this.props,
            min = _props.min,
            max = _props.max,
            marks = _props.marks;

        var scales = this._marksToScales(marks);
        // let scales = null;

        if (scales !== false) {
            if (Array.isArray(scales)) {
                return scales;
            } else {
                var pace = (max - min) / scales;
                var result = [];

                result.push(min);
                for (var i = 1; i < scales; i++) {
                    result.push(min + i * pace);
                }
                result.push(max);
                return result;
            }
        } else {
            return [];
        }
    };

    Range.prototype._calcMarks = function _calcMarks() {
        var _props2 = this.props,
            min = _props2.min,
            max = _props2.max,
            marks = _props2.marks;


        var result = {};

        if (Array.isArray(marks)) {
            marks.forEach(function (m) {
                result[m] = m.toString();
            });
        } else if (typeof marks === 'number') {
            var pace = (max - min) / marks;

            result[min] = min;
            for (var i = 1; i < marks; i++) {
                var mark = min + i * pace;
                var precision = (0, _utils.getPrecision)(mark);
                if (precision > 2) {
                    precision = 2;
                }
                mark = mark.toFixed(precision);
                result[mark] = mark;
            }
            result[max] = max;
        } else {
            result = marks;
        }
        return result;
    };

    Range.prototype._onMouseDown = function _onMouseDown(e) {
        this.setState({
            hasMovingClass: true
        });
        this._start(e.pageX);
        this._addDocumentEvents();
        pauseEvent(e);
    };

    Range.prototype._start = function _start(position) {
        var tempValue = this.state.tempValue;

        var range = this.dom;
        var start = range.getBoundingClientRect().left;

        // used in unit test
        var width = range.clientWidth;
        if (!width) {
            if (range.style.width) {
                var index = range.style.width.indexOf('px');
                if (index !== -1) {
                    width = Number(range.style.width.slice(0, index));
                }
            }
        }

        this._moving = {
            start: start,
            end: start + width,
            startValue: tempValue
        };

        // change on start
        this._onProcess(position, true);
    };

    Range.prototype._end = function _end() {
        var startValue = this._moving.startValue;
        var _state = this.state,
            tempValue = _state.tempValue,
            value = _state.value;

        this._moving = null;
        this._removeDocumentEvents();
        this.setState({
            hasMovingClass: false,
            lowerTooltipVisible: false,
            upperTooltipVisible: false,
            tooltipAnimation: true
        });
        if (!(0, _utils.isEqual)(tempValue, startValue)) {
            // Not Controlled
            if (!('value' in this.props)) {
                this.setState({
                    value: tempValue
                });
            } else {
                this.setState({
                    // tooltipVisible: false,
                    tempValue: value,
                    value: value
                });
            }
            this.props.onChange(tempValue);
        }
    };

    Range.prototype._move = function _move(e) {
        this._onProcess(e.pageX);
    };

    Range.prototype._onProcess = function _onProcess(position, start) {
        var tempValue = this.state.tempValue;

        var current = this._positionToCurrent(position); //current 为当前click的value

        if (start) {
            if (_isMultiple(this.props.slider)) {
                this._moving.dragging = (0, _utils.getDragging)(current, tempValue);
            } else {
                this._moving.dragging = 'upper';
            }

            this.setState({
                lowerTooltipVisible: this._moving.dragging === 'lower',
                upperTooltipVisible: this._moving.dragging === 'upper',
                tooltipAnimation: false
            });
        } else if (this.oldDragging === 'lower' && this._moving.dragging === 'upper') {
            this.setState({
                upperTooltipVisible: true,
                lowerTooltipVisible: false
            });
        } else if (this.oldDragging === 'upper' && this._moving.dragging === 'lower') {
            this.setState({
                upperTooltipVisible: false,
                lowerTooltipVisible: true
            });
        }

        this.oldDragging = this._moving.dragging;

        var nextValue = this._currentToValue(current, tempValue); //计算range的新value,可能是数组,可能是单个值
        if (!(0, _utils.isEqual)(nextValue, tempValue)) {
            this.setState({
                tempValue: nextValue
            });
            this.props.onProcess(nextValue);
        }
    };

    Range.prototype._addDocumentEvents = function _addDocumentEvents() {
        this._onMouseMoveListener = _nextUtil.events.on(document, 'mousemove', this._move.bind(this));
        this._onMouseUpListener = _nextUtil.events.on(document, 'mouseup', this._end.bind(this));
    };

    Range.prototype._removeDocumentEvents = function _removeDocumentEvents() {
        if (this._onMouseMoveListener) {
            this._onMouseMoveListener.off();
            this._onMouseMoveListener = null;
        }

        if (this._onMouseUpListener) {
            this._onMouseUpListener.off();
            this._onMouseUpListener = null;
        }
    };

    // position => current (value type)


    Range.prototype._positionToCurrent = function _positionToCurrent(position) {
        var _moving = this._moving,
            start = _moving.start,
            end = _moving.end;
        var _props3 = this.props,
            step = _props3.step,
            min = _props3.min,
            max = _props3.max;


        if (position < start) {
            position = start;
        } else if (position > end) {
            position = end;
        }
        var pecent = (0, _utils.getPercent)(start, end, position);

        // reset by step
        var newValue = parseFloat((Math.round(pecent / 100 * (max - min) / step) * step).toFixed((0, _utils.getPrecision)(step)));

        return min + newValue;
    };

    Range.prototype._currentToValue = function _currentToValue(current, preValue) {
        var dragging = this._moving.dragging;


        if (!_isMultiple(this.props.slider)) {
            return current;
        } else {
            var result = void 0;

            if (dragging === 'lower') {
                if (current > preValue[1]) {
                    result = [preValue[1], current];
                    this._moving.dragging = 'upper';
                } else {
                    result = [current, preValue[1]];
                }
            } else if (dragging === 'upper') {
                if (current < preValue[0]) {
                    result = [current, preValue[0]];
                    this._moving.dragging = 'lower';
                } else {
                    result = [preValue[0], current];
                }
            }

            return result;
        }
    };

    Range.prototype.handleLowerTooltipVisibleChange = function handleLowerTooltipVisibleChange(visible) {
        if (this.state.hasMovingClass) {
            return;
        }
        this.setState({
            lowerTooltipVisible: visible
        });
    };

    Range.prototype.handleUpperTooltipVisibleChange = function handleUpperTooltipVisibleChange(visible) {
        if (this.state.hasMovingClass) {
            return;
        }
        this.setState({
            upperTooltipVisible: visible
        });
    };

    Range.prototype.render = function render() {
        var _classNames,
            _this2 = this;

        var value = this._moving ? this.state.tempValue : this.state.value;

        var _props4 = this.props,
            prefix = _props4.prefix,
            min = _props4.min,
            max = _props4.max,
            disabled = _props4.disabled,
            style = _props4.style,
            id = _props4.id,
            slider = _props4.slider,
            reverse = _props4.reverse,
            className = _props4.className,
            marks = _props4.marks,
            marksPosition = _props4.marksPosition,
            hasTip = _props4.hasTip,
            tipRender = _props4.tipRender;

        var classes = (0, _classnames2.default)((_classNames = {}, _classNames[prefix + 'range'] = true, _classNames.disabled = disabled, _classNames[className] = className, _classNames));

        if (Array.isArray(value)) {
            value.forEach(function (item, index) {
                if (item > max) {
                    value[index] = max;
                }
            });
        } else if (value > max) {
            value = max;
        }

        var commonProps = {
            prefix: prefix,
            min: min,
            max: max,
            value: value,
            reverse: reverse,
            slider: slider,
            hasTip: hasTip,
            tipRender: tipRender,
            marksPosition: marksPosition,
            hasMovingClass: this.state.hasMovingClass,
            disabled: disabled
        };

        return _react2.default.createElement(
            'div',
            { ref: function ref(dom) {
                    _this2.dom = dom;
                }, className: classes, id: id, onMouseDown: disabled ? noop : this._onMouseDown.bind(this),
                style: style },
            marks !== false && marksPosition === 'above' ? _react2.default.createElement(_mark2.default, (0, _extends3.default)({}, commonProps, { marks: this._calcMarks() })) : null,
            _react2.default.createElement(
                'div',
                { className: prefix + 'range-inner' },
                _react2.default.createElement(_scale2.default, (0, _extends3.default)({}, commonProps, { scales: this._calcScales() })),
                _react2.default.createElement(_track2.default, commonProps),
                _react2.default.createElement(_selected2.default, commonProps),
                _react2.default.createElement(LowerSlider, (0, _extends3.default)({}, commonProps, {
                    hasMovingClass: this.state.hasMovingClass && this._moving && this._moving.dragging === 'lower',
                    tooltipVisible: this.state.lowerTooltipVisible,
                    onTooltipVisibleChange: this.handleLowerTooltipVisibleChange,
                    tooltipAnimation: this.state.tooltipAnimation ? { in: 'expandInUp', out: 'expandOutDown' } : false })),
                _react2.default.createElement(UpperSlider, (0, _extends3.default)({}, commonProps, {
                    hasMovingClass: this.state.hasMovingClass && this._moving && this._moving.dragging === 'upper',
                    tooltipVisible: this.state.upperTooltipVisible,
                    onTooltipVisibleChange: this.handleUpperTooltipVisibleChange,
                    tooltipAnimation: this.state.tooltipAnimation ? { in: 'expandInUp', out: 'expandOutDown' } : false }))
            ),
            marks !== false && marksPosition === 'below' ? _react2.default.createElement(_mark2.default, (0, _extends3.default)({}, commonProps, { marks: this._calcMarks() })) : null
        );
    };

    return Range;
}(_react2.default.Component), _class.contextTypes = {
    prefix: _propTypes2.default.string
}, _class.propTypes = {
    /**
     * 样式类名的品牌前缀
     */
    prefix: _propTypes2.default.string,
    /**
     * 自定义类名
     */
    className: _propTypes2.default.string,
    /**
     * 自定义内敛样式
     */
    style: _propTypes2.default.object,
    /**
     * 滑块个数
     * @enumdesc 单个, 两个
     */
    slider: _propTypes2.default.oneOf(['single', 'double']),
    /**
     * 最小值
     */
    min: _propTypes2.default.number,
    /**
     * 最大值
     */
    max: _propTypes2.default.number,
    /**
     * 步长，取值必须大于 0，并且可被 (max - min) 整除。
     */
    step: _propTypes2.default.number,
    /**
     * 设置当前取值。当 `slider` 为 `single` 时，使用 `Number`，否则用 `[Number, Number]`
     */
    value: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
    tempValue: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
    /**
     * 设置初始取值。当 `slider` 为 `single` 时，使用 `Number`，否则用 `[Number, Number]`
     */
    defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number)]),
    /**
     * 刻度数值显示逻辑（false 代表不显示，array 枚举显示的值，number 代表按 number 平分，object 表示按 key 划分，value 值显示）
     */
    marks: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.number, _propTypes2.default.arrayOf(_propTypes2.default.number), _propTypes2.default.object]),
    /**
     * marks显示在上方('above')or下方('below')
     */
    marksPosition: _propTypes2.default.oneOf(['above', 'below']),
    /**
     * 值为 `true` 时，滑块为禁用状态
     */
    disabled: _propTypes2.default.bool,
    /**
     * 当 Range 的值发生改变后，会触发 onChange 事件，并把改变后的值作为参数传入, 如果设置了value, 要配合此函数做受控使用
     * @param {String/number} value
     */
    onChange: _propTypes2.default.func,
    /**
     * 滑块拖动的时候触发的事件,不建议在这里setState, 一般情况下不需要用, 滑动时有特殊需求时使用
     * @param {String/number} value
     */
    onProcess: _propTypes2.default.func,
    /**
     * 是否显示tip
     */
    hasTip: _propTypes2.default.bool,
    /**
     * tip文件自定义处理
     */
    tipRender: _propTypes2.default.func,
    id: _propTypes2.default.string,
    /**
     * 选中态反转
     */
    reverse: _propTypes2.default.bool,
    /**
     * 是否pure render
     */
    pure: _propTypes2.default.bool
}, _class.defaultProps = {
    prefix: 'next-',
    slider: 'single',
    min: 0,
    max: 100,
    step: 1,
    marks: false,
    disabled: false,
    hasTip: true,
    onChange: noop,
    onProcess: noop,
    tipRender: function tipRender(value) {
        return value;
    },
    reverse: false,
    pure: false,
    marksPosition: 'above'
}, _temp);
Range.displayName = 'Range';
exports.default = Range;
module.exports = exports['default'];