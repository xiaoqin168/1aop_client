'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _nextUtil = require('../../../next-util/lib/index.js');

var _nextConfigProvider = require('../../../next-config-provider/lib/index.js');

var _nextConfigProvider2 = _interopRequireDefault(_nextConfigProvider);

var _create = require('./create.js');

var _create2 = _interopRequireDefault(_create);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var config = _nextConfigProvider2.default.config;
var bindCtx = _nextUtil.func.bindCtx;
var pickOthers = _nextUtil.obj.pickOthers;

var noop = function noop() {};

/**
 * Menu
 */
var Menu = (_temp = _class = function (_Component) {
    (0, _inherits3.default)(Menu, _Component);

    function Menu(props) {
        (0, _classCallCheck3.default)(this, Menu);

        var _this = (0, _possibleConstructorReturn3.default)(this, _Component.call(this, props));

        var _this$props = _this.props,
            openKeys = _this$props.openKeys,
            defaultOpenKeys = _this$props.defaultOpenKeys,
            selectedKeys = _this$props.selectedKeys,
            defaultSelectedKeys = _this$props.defaultSelectedKeys,
            focusedKey = _this$props.focusedKey;


        _this.state = {
            openKeys: _this.normalizeToArray(openKeys || defaultOpenKeys),
            selectedKeys: _this.normalizeToArray(selectedKeys || defaultSelectedKeys),
            focusedKey: focusedKey
        };

        bindCtx(_this, ['handleOpen', 'handleSelect', 'handleItemClick', 'handleItemKeyDown', 'handleKeyDown']);

        _this.popupNodes = [];
        return _this;
    }

    /**
     * 创建上下文菜单
     * @param {Object} props 属性对象
     */


    Menu.prototype.componentDidMount = function componentDidMount() {
        this.menuNode = (0, _reactDom.findDOMNode)(this);
        if (this.props.autoFocus) {
            this.menuNode.focus();
        }
    };

    Menu.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var state = {};

        if ('openKeys' in nextProps) {
            state.openKeys = nextProps.openKeys;
        }
        if ('selectedKeys' in nextProps) {
            state.selectedKeys = nextProps.selectedKeys;
        }
        if ('focusedKey' in nextProps) {
            state.focusedKey = nextProps.focusedKey;
        }

        if (Object.keys(state).length) {
            this.setState(state);
        }
    };

    Menu.prototype.normalizeToArray = function normalizeToArray(items) {
        if (items) {
            if (Array.isArray(items)) {
                return items;
            }
            return [items];
        }

        return [];
    };

    Menu.prototype.isSibling = function isSibling(currentPos, targetPos) {
        var currentNums = currentPos.split('-').slice(0, -1);
        var targetNums = targetPos.split('-').slice(0, -1);

        return currentNums.length === targetNums.length && currentNums.every(function (num, index) {
            return num === targetNums[index];
        });
    };

    Menu.prototype.isAncestor = function isAncestor(currentPos, targetPos) {
        var currentNums = currentPos.split('-');
        var targetNums = targetPos.split('-');

        return currentNums.length > targetNums.length && targetNums.every(function (num, index) {
            return num === currentNums[index];
        });
    };

    Menu.prototype.handleOpen = function handleOpen(key, open, triggerType, e) {
        var _this2 = this;

        var newOpenKeys = void 0;

        var _props = this.props,
            mode = _props.mode,
            openMode = _props.openMode;
        var openKeys = this.state.openKeys;

        var index = openKeys.indexOf(key);
        if (open && index === -1) {
            if (mode === 'inline') {
                if (openMode === 'single') {
                    newOpenKeys = openKeys.filter(function (k) {
                        return !_this2.isSibling(_this2.k2n[key].pos, _this2.k2n[k].pos);
                    });
                    newOpenKeys.push(key);
                } else {
                    newOpenKeys = openKeys.concat(key);
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return _this2.isAncestor(_this2.k2n[key].pos, _this2.k2n[k].pos);
                });
                newOpenKeys.push(key);
            }
        } else if (!open && index > -1) {
            if (mode === 'inline') {
                newOpenKeys = [].concat(openKeys.slice(0, index), openKeys.slice(index + 1));
            } else if (triggerType === 'docClick') {
                if (!this.popupNodes.concat(this.menuNode).some(function (node) {
                    return node.contains(e.target);
                })) {
                    newOpenKeys = [];
                }
            } else {
                newOpenKeys = openKeys.filter(function (k) {
                    return k !== key && !_this2.isAncestor(_this2.k2n[k].pos, _this2.k2n[key].pos);
                });
            }
        }

        if (newOpenKeys) {
            if (!('openKeys' in this.props)) {
                this.setState({
                    openKeys: newOpenKeys
                });
            }

            this.props.onOpen(newOpenKeys, {
                key: key,
                open: open
            });
        }
    };

    Menu.prototype.getKeyPath = function getKeyPath(key) {
        var keyPath = [];

        var pos = this.k2n[key].pos;
        var nums = pos.split('-');
        for (var i = 1; i < nums.length - 1; i++) {
            var parentNums = nums.slice(0, i + 1);
            var parentPos = parentNums.join('-');
            var parentKey = this.p2n[parentPos].key;
            keyPath.push(parentKey);
        }

        return keyPath;
    };

    Menu.prototype.handleSelect = function handleSelect(key, select, menuItem) {
        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        if (this.props.shallowSelect && level > 1) {
            return;
        }

        var newSelectedKeys = void 0;

        var selectMode = this.props.selectMode;
        var selectedKeys = this.state.selectedKeys;

        var index = selectedKeys.indexOf(key);
        if (select && index === -1) {
            if (selectMode === 'single') {
                newSelectedKeys = [key];
            } else if (selectMode === 'multiple') {
                newSelectedKeys = selectedKeys.concat(key);
            }
        } else if (!select && index > -1 && selectMode === 'multiple') {
            newSelectedKeys = [].concat(selectedKeys.slice(0, index), selectedKeys.slice(index + 1));
        }

        if (newSelectedKeys) {
            if (!('selectedKeys' in this.props)) {
                this.setState({
                    selectedKeys: newSelectedKeys
                });
            }

            this.props.onSelect(newSelectedKeys, menuItem, {
                key: key,
                select: select,
                label: menuItem.props.children,
                keyPath: this.getKeyPath(key)
            });
        }
    };

    Menu.prototype.handleItemClick = function handleItemClick(key, item, e) {
        if (this.props.focusable) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: key
                });
            }

            this.props.onItemFocus(key, item, e);
        }

        if (item.props.type === 'item') {
            this.props.onItemClick(key, item, e);
        }
    };

    Menu.prototype.isAvailablePos = function isAvailablePos(refPos, targetPos) {
        var _p2n$targetPos = this.p2n[targetPos],
            type = _p2n$targetPos.type,
            disabled = _p2n$targetPos.disabled;


        return this.isSibling(refPos, targetPos) && (type === 'item' && !disabled || type === 'submenu');
    };

    Menu.prototype.getAvailableKey = function getAvailableKey(pos, prev) {
        var _this3 = this;

        var ps = Object.keys(this.p2n).filter(function (p) {
            return _this3.isAvailablePos(pos, p);
        });
        if (ps.length > 1) {
            var index = ps.indexOf(pos);
            var targetIndex = void 0;
            if (prev) {
                targetIndex = index === 0 ? ps.length - 1 : index - 1;
            } else {
                targetIndex = index === ps.length - 1 ? 0 : index + 1;
            }

            return this.p2n[ps[targetIndex]].key;
        }

        return null;
    };

    Menu.prototype.getFirstAvaliablelChildKey = function getFirstAvaliablelChildKey(parentPos) {
        var _this4 = this;

        var pos = Object.keys(this.p2n).find(function (p) {
            return _this4.isAvailablePos(parentPos + '-0', p);
        });
        return pos ? this.p2n[pos].key : null;
    };

    Menu.prototype.getParentKey = function getParentKey(pos) {
        return this.p2n[pos.slice(0, pos.length - 2)].key;
    };

    Menu.prototype.handleItemKeyDown = function handleItemKeyDown(key, type, item, e) {
        if ([_nextUtil.KEYCODE.UP, _nextUtil.KEYCODE.DOWN, _nextUtil.KEYCODE.RIGHT, _nextUtil.KEYCODE.LEFT, _nextUtil.KEYCODE.ENTER, _nextUtil.KEYCODE.ESC, _nextUtil.KEYCODE.SPACE].indexOf(e.keyCode) > -1) {
            e.preventDefault();
            e.stopPropagation();
        }

        var focusedKey = this.state.focusedKey;

        var direction = this.props.direction;

        var pos = this.k2n[key].pos;
        var level = pos.split('-').length - 1;
        switch (e.keyCode) {
            case _nextUtil.KEYCODE.UP:
                {
                    var avaliableKey = this.getAvailableKey(pos, true);
                    if (avaliableKey) {
                        focusedKey = avaliableKey;
                    }
                    break;
                }
            case _nextUtil.KEYCODE.DOWN:
                {
                    var _avaliableKey = void 0;
                    if (direction === 'hoz' && level === 1 && type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey = this.getFirstAvaliablelChildKey(pos);
                    } else {
                        _avaliableKey = this.getAvailableKey(pos, false);
                    }
                    if (_avaliableKey) {
                        focusedKey = _avaliableKey;
                    }
                    break;
                }
            case _nextUtil.KEYCODE.RIGHT:
                {
                    var _avaliableKey2 = void 0;
                    if (direction === 'hoz' && level === 1) {
                        _avaliableKey2 = this.getAvailableKey(pos, false);
                    } else if (type === 'submenu') {
                        this.handleOpen(key, true);
                        _avaliableKey2 = this.getFirstAvaliablelChildKey(pos);
                    }
                    if (_avaliableKey2) {
                        focusedKey = _avaliableKey2;
                    }
                    break;
                }
            case _nextUtil.KEYCODE.ENTER:
                {
                    if (type === 'submenu') {
                        this.handleOpen(key, true);
                        var _avaliableKey3 = this.getFirstAvaliablelChildKey(pos);
                        if (_avaliableKey3) {
                            focusedKey = _avaliableKey3;
                        }
                    }
                    break;
                }
            case _nextUtil.KEYCODE.LEFT:
                {
                    if (direction === 'hoz' && level === 1) {
                        var _avaliableKey4 = this.getAvailableKey(pos, true);
                        if (_avaliableKey4) {
                            focusedKey = _avaliableKey4;
                        }
                    } else if (level > 1) {
                        var parentKey = this.getParentKey(pos);
                        this.handleOpen(parentKey, false);
                        focusedKey = parentKey;
                    }
                    break;
                }
            case _nextUtil.KEYCODE.ESC:
                if (level > 1) {
                    var _parentKey = this.getParentKey(pos);
                    this.handleOpen(_parentKey, false);
                    focusedKey = _parentKey;
                }
                break;

            case _nextUtil.KEYCODE.TAB:
                focusedKey = null;
                break;
            default:
                break;
        }

        if (focusedKey !== this.state.focusedKey) {
            if (!('focusedKey' in this.props)) {
                this.setState({
                    focusedKey: focusedKey
                });
            }

            this.props.onItemKeyDown(focusedKey, item, e);
            this.props.onItemFocus(focusedKey, e);
        }
    };

    Menu.prototype.handleKeyDown = function handleKeyDown(e) {
        if (e.keyCode === _nextUtil.KEYCODE.ENTER || e.keyCode === _nextUtil.KEYCODE.RIGHT || e.keyCode === _nextUtil.KEYCODE.DOWN) {
            e.preventDefault();
            e.stopPropagation();

            var focusedKey = this.getFirstAvaliablelChildKey('0');
            if (focusedKey) {
                if (!('focusedKey' in this.props)) {
                    this.setState({
                        focusedKey: focusedKey
                    });
                }

                this.props.onItemFocus(focusedKey, e);
            }
        }
    };

    Menu.prototype.render = function render() {
        var _this5 = this,
            _cx;

        var _props2 = this.props,
            prefix = _props2.prefix,
            className = _props2.className,
            children = _props2.children,
            direction = _props2.direction,
            header = _props2.header,
            footer = _props2.footer,
            focusable = _props2.focusable;

        var others = pickOthers(Object.keys(Menu.propTypes), this.props);
        if (focusable) {
            others.tabIndex = 0;
            others.onKeyDown = function (e) {
                _this5.handleKeyDown(e);
                _this5.props.onKeyDown && _this5.props.onKeyDown(e);
            };
        }

        var newClassName = (0, _classnames2.default)((_cx = {}, _cx[prefix + 'menu'] = true, _cx[prefix + 'ver'] = direction === 'ver', _cx[prefix + 'hoz'] = direction === 'hoz', _cx[className] = !!className, _cx));

        this.k2n = {};
        this.p2n = {};
        var loop = function loop(children, posPrefix) {
            var indexWrapper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { index: 0 };

            return _react.Children.map(children, function (child) {
                if (child && typeof child.type === 'function' && 'menuChildType' in child.type) {
                    var newChild = void 0;

                    var pos = void 0;
                    var props = { root: _this5 };
                    if (child.type.menuChildType === 'item' || child.type.menuChildType === 'submenu') {
                        pos = posPrefix + '-' + indexWrapper.index++;
                        var key = typeof child.key === 'string' ? child.key : pos;
                        var level = pos.split('-').length - 1;
                        _this5.k2n[key] = _this5.p2n[pos] = {
                            key: key,
                            pos: pos,
                            type: child.type.menuChildType,
                            disabled: child.props.disabled
                        };

                        props._key = key;
                        props.level = level;
                    }

                    switch (child.type.menuChildType) {
                        case 'submenu':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, pos));
                            break;
                        case 'group':
                            newChild = (0, _react.cloneElement)(child, props, loop(child.props.children, posPrefix, indexWrapper));
                            break;
                        case 'item':
                        case 'divider':
                            newChild = (0, _react.cloneElement)(child, props);
                            break;
                        default:
                            newChild = child;
                            break;
                    }

                    return newChild;
                }

                return child;
            });
        };

        var newChildren = loop(children, '0');

        var role = direction === 'hoz' ? 'menubar' : 'menu';

        return _react2.default.createElement(
            'ul',
            (0, _extends3.default)({ role: role, className: newClassName, onKeyDown: this.handleEnter }, others),
            header ? _react2.default.createElement(
                'li',
                { className: prefix + 'menu-header' },
                header
            ) : null,
            header || footer ? _react2.default.createElement(
                'ul',
                { className: prefix + 'menu-content' },
                newChildren
            ) : newChildren,
            footer ? _react2.default.createElement(
                'li',
                { className: prefix + 'menu-footer' },
                footer
            ) : null
        );
    };

    return Menu;
}(_react.Component), _class.propTypes = {
    prefix: _propTypes2.default.string,
    pure: _propTypes2.default.bool,
    className: _propTypes2.default.string,
    /**
     * 菜单项和子菜单
     */
    children: _propTypes2.default.node,
    /**
     * 点击菜单项触发的回调函数
     * @param {String} key 点击的菜单项的 key 值
     * @param {Object} item 点击的菜单项对象
     * @param {Object} event 点击的事件对象
     */
    onItemClick: _propTypes2.default.func,
    /**
     * 当前打开的子菜单的 key 值
     */
    openKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始打开的子菜单的 key 值
     */
    defaultOpenKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 打开或关闭子菜单触发的回调函数
     * @param {String} key 打开的所有子菜单的 key 值
     * @param {Object} extra 额外参数
     * @param {String} extra.key 当前操作子菜单的 key 值
     * @param {Boolean} extra.open 是否是打开
     */
    onOpen: _propTypes2.default.func,
    /**
     * 子菜单打开的模式
     */
    mode: _propTypes2.default.oneOf(['inline', 'popup']),
    /**
     * 子菜单打开的触发行为
     */
    triggerType: _propTypes2.default.oneOf(['click', 'hover']),
    /**
     * 展开内连子菜单的模式，同时可以展开一个子菜单还是多个子菜单，该属性仅在 mode 为 inline 时生效
     */
    openMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 内连子菜单缩进距离
     */
    inlineIndent: _propTypes2.default.number,
    inlineArrowDirection: _propTypes2.default.oneOf(['down', 'right']),
    /**
     * 是否自动让弹层的宽度和菜单项保持一致，如果弹层的宽度比菜单项小则和菜单项保持一致，如果宽度大于菜单项则不做处理
     */
    popupAutoWidth: _propTypes2.default.bool,
    /**
     * 弹层的对齐方式
     */
    popupAlign: _propTypes2.default.oneOf(['follow', 'outside']),
    /**
     * 弹层自定义 props
     */
    popupProps: _propTypes2.default.object,
    /**
     * 弹出子菜单自定义 className
     */
    popupClassName: _propTypes2.default.string,
    /**
     * 弹出子菜单自定义 style
     */
    popupStyle: _propTypes2.default.object,
    /**
     * 当前选中菜单项的 key 值
     */
    selectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 初始选中菜单项的 key 值
     */
    defaultSelectedKeys: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.array]),
    /**
     * 选中或取消选中菜单项触发的回调函数
     * @param {Array} selectedKeys 选中的所有菜单项的值
     * @param {Object} item 选中或取消选中的菜单项
     * @param {Object} extra 额外参数
     * @param {Boolean} extra.select 是否是选中
     * @param {Array} extra.key 菜单项的 key
     * @param {Object} extra.label 菜单项的文本
     * @param {Array} extra.keyPath 菜单项 key 的路径
     */
    onSelect: _propTypes2.default.func,
    /**
     * 选中模式，单选还是多选，默认无值，不可选
     */
    selectMode: _propTypes2.default.oneOf(['single', 'multiple']),
    /**
     * 是否只能选择第一层菜单项（不能选择子菜单中的菜单项）
     */
    shallowSelect: _propTypes2.default.bool,
    /**
     * 是否显示选中图标，如果设置为 false 需配合配置平台设置选中时的背景色以示区分
     */
    hasSelectedIcon: _propTypes2.default.bool,
    labelToggleChecked: _propTypes2.default.bool,
    /**
     * 菜单第一层展示方向
     */
    direction: _propTypes2.default.oneOf(['ver', 'hoz']),
    /**
     * 自定义菜单头部
     */
    header: _propTypes2.default.node,
    /**
     * 自定义菜单尾部
     */
    footer: _propTypes2.default.node,
    /**
     * 是否自动获得焦点
     */
    autoFocus: _propTypes2.default.bool,
    /**
     * 当前获得焦点的子菜单或菜单项 key 值
     */
    focusedKey: _propTypes2.default.string,
    focusable: _propTypes2.default.bool,
    onItemFocus: _propTypes2.default.func,
    onItemKeyDown: _propTypes2.default.func,
    expandAnimation: _propTypes2.default.bool,
    itemClassName: _propTypes2.default.string
}, _class.defaultProps = {
    prefix: 'next-',
    pure: false,
    defaultOpenKeys: [],
    onOpen: noop,
    mode: 'inline',
    triggerType: 'click',
    openMode: 'multiple',
    inlineIndent: 20,
    inlineArrowDirection: 'down',
    popupAutoWidth: false,
    popupAlign: 'follow',
    defaultSelectedKeys: [],
    onSelect: noop,
    shallowSelect: false,
    hasSelectedIcon: true,
    labelToggleChecked: true,
    direction: 'ver',
    autoFocus: false,
    focusable: true,
    onItemFocus: noop,
    onItemKeyDown: noop,
    onItemClick: noop,
    expandAnimation: true
}, _class.create = function (props) {
    (0, _create2.default)(props);
}, _temp);
Menu.displayName = 'Menu';
exports.default = config(Menu);
module.exports = exports['default'];